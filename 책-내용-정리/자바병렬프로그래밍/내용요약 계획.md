[자바 병렬 프로그래밍](http://www.yes24.com/Product/Goods/3015162)에 따르면, 스레드 갯수를 늘리거나, 하드웨어를 올리거나 하는 것 역시 해결방법이 될 수 있지만 가장 좋은 방법은 작업의 갯수를 최소화하는 것이라고 꽤 자주 언급해주는 편이다.

Java 에서 제공하는 ExecutorService 에 대한 세부적인 내용들과 Executors 에서 제공하는 4 종류의 헬퍼 메서드는 ExecutorService가 내부적으로는 어떤 방식으로 동작하는지 알아야 데이터 처리 지연 장애발생할 때 대응이 가능했다. Executors 에서 제공하는 네 종류의 헬퍼 메서드들 역시 현업에서는 그대로 사용하지 못했다. 데이터의 처리가 급증할 때 스레드 풀의 설정을 이미 제공하는 방식 그대로 사용하기에는 부족했기 때문.

(참고로 Executor 는 ExecutorService의 상위타입이다. 그리고 Executor, ExecutorService 모두 interface이다.)

<br>

이런 이유로 스레드 풀을 작업 처리에 적합하게 커스터마이징한 ThreadPoolExecutor 객체를 구성해서 작업자를 정의했었다. 참고로 작업을 처리하는 Executors에서 제공하는 4 종류의 헬퍼 메서드들은 모두 내부적으로 ThreadPoolExecutor 객체를 생성하고 있다. 

이 메서드들을 커스터마이징해서 사용했는데, 초보 개발자들이 저지르는 실수 처럼 스레드 풀을 100개... 이런식으로 말도 안되게 잡지는 않았고, 각 작업의 레이턴시와 작업 처리 주기를 설정한다음 작업주기/레이턴시에 맞게 고려해서 min =1, max =3 같은 방식으로 스레드를 최대한 보수적으로 잡았었다. 이렇게 잡으려면 레이턴시를 모두 측정해야하고 이에 맞게 정해진 주기에 작업이 소모가능하도록 작업 주기도 데이터에 기반해서 잡아야 한다.<br>

<br>



코틀린의 코루틴을 최근에 공부했는데, 코루틴을 이용한 데이터 처리 역시 위의 내용을 어느 정도는 부합시킬 수 있겠다는 생각이 들었다. 중간에 코틀린의 코루틴을 공부하면서 인터넷의 한 자료에서 'Dispatchers' 에서 제공하는 코루틴 스코프 정의를 벗어나는 경우는 거의 없다고 했지만, 어디까지나 클라이언트 측면에서의 처리일 경우에 대한 가정이 아닐까 싶었다. 서버는 1 vs N 의 데이터를 모두 받을 수 있어야 하기에 코틀린 코루틴 처리시 스레드 풀에 대해 어느 정도는 알고서 사용할 줄 알아야 하고 코루틴 스코프 역시 어느 정도는 작업 주기와 레이턴시를 고려해서 커스텀하게 설정할수 있어야 한다는 생각이 들었다.

<br>



마음이 급하다보니 또 횡설수설했다. 정리 다시 시작해야지 싶다. 

결론은 이렇다.

여기에 정리하고 싶은 내용은 Executor, ExecutorService 에서 작업큐를 소모하는 절차, 각각의 프로퍼티들의 의미 등등 이런 내용들이다. 구체적인 내용은 조금 숨겨두고 요약 위주로 정리해야겠다 싶다.<br>

